<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.24.79"/><link as="script" rel="preload" href="/webpack-runtime-6b3b87391c7a86b77c10.js"/><link as="script" rel="preload" href="/framework-acb96471af32e2ccbc9d.js"/><link as="script" rel="preload" href="/app-10b6f47e5429585ae360.js"/><link as="script" rel="preload" href="/component---src-templates-post-js-0ec6894045e055c72fc7.js"/><link as="fetch" rel="preload" href="/page-data/posts/sloth-every-hour/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><h1>Sloth Every Hour</h1><p>Mon Jun 15 2020</p><div><p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 300px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/5e589750b8d49cc519b4ae0ada643197/5a46d/Screen-Shot-2020-06-14-at-5.14.11-PM-300x158.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 52.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC0ElEQVQoz22R60+aBxSH36RftqbJenlhXgsVFLkoCHKzCIJclBLuIFgR3ETF1lELHbE6cVu6bNrM2WZ2SWVxoc0+dGsXlzT9tC/b//Xs1TRNl+zDk5NzyS+/c44wGbLz89Fz/jz5i6OnLVrtY+qNCs3vNylvLRKLe1n4tEAqHcU7bmHcYcDlMVOoRchUJ8g0Qix/vcBYqgtn6hLCo73HnLz6m4O9Q1pPWrSP2yyW8gSmHCxVsnzZbNDYalBv1ln/fJXMXBKH30h8zUHknpHF7+YobCSZbfhJ3BlGONg9IugLEp6coDib4Lp1EI1KxB80crC/x+vfTogGPUxO2KivrfDil2dE005ulFzUHm2xtl+i+vAzNo+ljbanEU5dxWeCGMwddHZ9wMUL5+jvu0w25+eFJPb7r3+QCPiw23rxeUzcXioRmrlGYMFO8UGceM1EZMXN8r6P9H09ws5OhW9beRbvOvHGBshX4qiUIkG3hS82N3j840+8evmG5naVeNJB9fYshXKYYiVJeT3MzbKHG2kr2SUXqxsphI2VFI21BIXcKKmklto3Ve5+dY/ezg8x6RXSM6b54eCQN6//4c6tMrnMOPPzcTI3kxQ/SbNczpHLRwhPu0jH3Aj+YSX94kViPgvr9UHmV900n+zidGnpUXyE1aZhatrD9s4D2u2X5KXzTPhHsY4NMzSqxj9pYWREjcHYi07fjZD1DuKzymnUpjhq5zA6hxCvalHoTHSotHSqDXSpDMiVWvoMdq5qTMj7tMiUGmSqIbrtYeRmPx9bgnQMjCC4PVoOn7rY3Y/hDjk5L1MjKnVclkRFhZ4rCt0ZosSlXs27+mkuU5uR2WLIbVFk1giiyoQQyZZIzeWZKRbxhmcIRLN0D5gkkVMXegnd2/g+ujPORHv6EXskE1KUSblwPZTAODaF2R1mxBVAPexAfs1wNnzq9H/5T0//Hjr+BbA8nMKQmtSGAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Screen Shot 2020 06 14 at 5 14 11 PM 300x158"
        title="Screen Shot 2020 06 14 at 5 14 11 PM 300x158"
        src="/static/5e589750b8d49cc519b4ae0ada643197/5a46d/Screen-Shot-2020-06-14-at-5.14.11-PM-300x158.png"
        srcset="/static/5e589750b8d49cc519b4ae0ada643197/5a46d/Screen-Shot-2020-06-14-at-5.14.11-PM-300x158.png 300w"
        sizes="(max-width: 300px) 100vw, 300px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p>
<p>If you've read my last post you'd know that I was recently looking for an API endpoint that provided random images of Sloths for a project I wanted to work on. After searching for this tool and realizing it didn't exist, I ended up building it myself (<em>you can access and use the Sloth API at <a href="https://Sloth.pics">Sloth.pics</a>, as well as read my blog post about it <a href="https://technicode.io/index.php/2020/06/05/sloth-pics/">here</a></em>).</p>
<p>But anyway<strong>,</strong> the project I initially wanted to make was <a href="https://twitter.com/SlothEveryHour">Sloth Every Hour</a>. A Twitter bot that posts images of sloths every hour, very much in the inspired by accounts like <a href="https://twitter.com/PossumEveryHour">@PossumEveryHour.</a> I was seeing accounts like this pop-up quite a bit on my Twitter feed and was curious about how these accounts worked. A few of them seemed to be posted via automation tools like IFTTT, but a number of them claimed to be manual. I thought this was crazy. Who has the time to manually search for pictures and post them every hour?!</p>
<p>This got me thinking and I realized that this could be a really fun project to work on. Some sort of bot that would continually search for images, confirm what's in them, and then post to twitter. This is what led me to build Sloth.pics.</p>
<p>Now that I had the first part of this complete, all I had to do was make an app that could send an HTTP GET request to the Sloth API, download the image from the URL I received and then upload that image back to Twitter. Rinse and Repeat.</p>
<h2>The Build</h2>
<p>This turned out to be really easy. I once again built this bot using Node.js as it's what I'm most familiar with. I used <a href="https://www.npmjs.com/package/axios">Axios</a> to send my HTTP requests and <a href="https://www.npmjs.com/package/image-downloader">Image-downloader</a> to download each sloth image from the API as Twitter won't show an image from its URL. And lastly, I used the <a href="https://www.npmjs.com/package/twitter">Twitter NPM package</a> to upload my media and send out each tweet.</p>
<p>In order to send tweets via Twitter's API, I needed to set up a Twitter Developer account and create an app through their interface to get my hands on the API keys needed to actually send tweets programmatically. Once I had those, I was all set and ready to get started!</p>
<p>At the end of the day, abstracting the image collection/sorting from this project made the twitter side incredibly easy. The actual bot is really just 3 functions running in a setInterval every hour.</p>
<p>First I had to grab the image data from the API:</p>
<pre><code>async function getSlothThenTweet(cb) {
  const resp = await axios.get('https://sloth.pics/api');
  const sloth = resp.data;
  const options = {
    url: sloth.url,
    dest: './sloth.jpg',
  };
  download
    .image(options)
    .then(data => {
      cb('./sloth.jpg', sloth);
    })
    .catch(err => console.log(err));
}
</code></pre>
<p>This function handles getting the image, downloading it, and then calls on the function passed to it in the parameters. The callback function is what actually handles uploading and sending out the initial tweet, as you can see here:</p>
<pre><code>function sendTweet(imagePath, sloth) {
  const data = require('fs').readFileSync(imagePath);

  client.post('media/upload', { media: data }, (error, media, response) => {
    if (!error) {
      const status = {
        status: `Photo by ${sloth.creator}`,
        media_ids: media.media_id_string,
      };

      client.post('statuses/update', status, (error, tweet, response) => {
        if (!error) {
          console.log('Sent Tweet.');
          const tweetId = tweet.id_str;
          sendReplies(
            {
              status: `Link to Photographer: ${sloth.creator_url}`,
              in_reply_to_status_id: tweetId,
              username: '@slotheveryhour',
            },
            {
              status: `Photo License: ${sloth.license} => ${sloth.license_url}`,
              in_reply_to_status_id: null,
              username: '@slotheveryhour',
            }
          );
        }
      });
    } else {
      console.log(error);
    }
  });
}
</code></pre>
<p>This function reads the image from the specified file path and then uploads it to twitter via the client.post('media/upload'). This doesn't actually post it though. We need to then run client.post again but with the ('statuses/update') parameter for the tweet to actually be posted. So that's exactly what we do after. Then once I confirm no errors sending the tweet, I grab the tweet ID and then use it to attach a reply which contains a link to the photographer's Flickr page. And I do that once more to grab the reply's ID and attached another reply which contains info about the image's license:</p>
<pre><code>function sendReplies(first, second) {
  client.post('statuses/update', first).then(tweet => {
    const replyId = tweet.id_str;
    second.in_reply_to_status_id = replyId;
    client.post('statuses/update', second);
  });
}
</code></pre>
<p>Once I had this all set up, I just threw the function calls into a setInterval which runs every 3,600,000 milliseconds!</p>
<pre><code>getSlothThenTweet(sendTweet);
setInterval(() => {
  getSlothThenTweet(sendTweet);
}, 3600000);
</code></pre>
<blockquote>
<p>Just a side note, I'm calling getSlothThenTweet here before the setInterval specifically because setInterval won't initially call the function until after the specified time frame, so if you want your function to run once when you start your app, you have to call that function first!</p>
</blockquote>
<h2>Hosting</h2>
<p>Once again I'm hosting through Heroku. It's just incredibly easy to get an app up and running through Heroku, that I couldn't not use it again, and since I'm not making the bot accessible via the web, it was actually even easier to set then Sloth.pics!</p>
<h2>Things to Change</h2>
<p>Honestly, this project was so easy and simple that I really can't see myself wanting to change anything with it in the future. Any thing I'd want to change would really be on the Sloth API side, rather than the Twitter side. So I guess really not much will change with this one!</p>
<p>If you'd like to look at the code for this project, you can do so <a href="https://github.com/ktomanelli/SlothEveryHour">here</a>!</p></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/sloth-every-hour";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-72546b9ca477f57c2f2e.js"],"app":["/app-10b6f47e5429585ae360.js"],"component---src-pages-index-js":["/component---src-pages-index-js-9b510899e4283203f3a3.js"],"component---src-templates-post-js":["/component---src-templates-post-js-0ec6894045e055c72fc7.js"]};/*]]>*/</script><script src="/polyfill-72546b9ca477f57c2f2e.js" nomodule=""></script><script src="/component---src-templates-post-js-0ec6894045e055c72fc7.js" async=""></script><script src="/app-10b6f47e5429585ae360.js" async=""></script><script src="/framework-acb96471af32e2ccbc9d.js" async=""></script><script src="/webpack-runtime-6b3b87391c7a86b77c10.js" async=""></script></body></html>